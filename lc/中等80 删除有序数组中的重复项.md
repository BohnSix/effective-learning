# 简单 删除有序数组中的重复项 `https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/`
# 中等 删除有序数组中的重复项 II `https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/`
* 双指针  快慢指针

# 删除有序数组中的重复项
* 对于一个传入的数组，用双指针 i 和 j 标记，从 1 开始迭代 j 。
    * 当 nums[i] 和 nums[j] 不相等时，先将 i 加一，指向  nums[i+1] 的数字并将 nums[j] 赋给 nums[i+1]。此时有两种情况
        * 如果 nums[i] 和 nums[i+1] 相等，则 nums[i+1] 可以直接被 nums[j] 覆盖。
        * 如果 nums[i] 和 nums[i+1] 不相等，则应有 nums[j] 和 nums[i+1] 相等。
    * 当 nums[i] 和 nums[j] 相等时，直接将 j 加一判断下一位。

    对于数组 【1， 1， 1， 2， 2， 3 】程序的处理结果应该是

    【1(i)， 1(j)， 1， 2， 2， 3】
    【1(i)， 1， 1(j)， 2， 2， 3 】
    【1(i)， 1， 1， 2(j)， 2， 3 】 // 此时 i 和 j 指向的数字开始不同
    【1， 1(i)， 1， 2(j)， 2， 3 】// 将 i 加一
    【1， 2(i)， 1， 2(j)， 2， 3 】// 将 j 的值赋给 i
    【1， 2(i)， 1， 2， 2(j)， 3 】// 再继续迭代 j
    【1， 2(i)， 1， 2， 2， 3(j) 】// 此时 i 和 j 指向的数字开始不同
    【1， 2， 1(i)， 2， 2， 3(j) 】// 将 i 加一
    【1， 2， 3(i)， 2， 2， 3(j) 】// 将 j 的值赋给 i 。此时 j 的迭代结束，i 的长度是 3，但索引值是 2，输出时应加一。

# 删除有序数组中的重复项 II
* 同理对于传入的数组，最多有两个重复数值。则还应判断是否与前一个数值相等。
* 剪枝。用 fast 和 slow 两个指针先从索引值为 2 的地方开始迭代快指针，如果快指针和慢指针前两位的值相等，说明慢指针是该数字第三次重复出现的位置，用快指针的值将其覆盖，否则继续迭代快指针。


对于数组 【1， 1， 1， 1， 2，3， 3， 3， 4】

    【1(i-2)， 1， 1(i)(j)， 1， 2，3， 3， 3， 4】
    【1(i-2)， 1， 1(i)， 1(j)， 2，3， 3， 3， 4】
    【1(i-2)， 1， 1(i)， 1， 2(j)，3， 3， 3， 4】// 此时快指针和慢指针前两位的值不等，说明慢指针指向了该数字第三次出现的位置。
    【1(i-2)， 1， 2， 1(i)， 2(j)，3， 3， 3， 4】// 用快指针的值将慢指针覆盖，然后移动慢指针
    【1， 1(i-2)， 2， 1(i)， 2，3(j)， 3， 3， 4】// 继续迭代快慢指针
    【1， 1(i-2)， 2， 3(i)， 2，3(j)， 3， 3， 4】// 此时快指针和慢指针前两位的值还是不等，继续覆盖
    【1， 1， 2(i-2)， 3， 2(i)，3， 3(j)， 3， 4】// 更改后同时移动快慢指针，发现还是不等，说明 i 和 i-2 之间的数字被更改只出现了一次，继续将后面的数字往前移
    【1， 1， 2， 3(i-2)， 3，3(i)， 3， 3(j)， 4】// 此时快指针和慢指针前两位的数字相等，只迭代快指针
    【1， 1， 2， 3(i-2)， 3，3(i)， 3， 3， 4(j)】// 此时快指针和慢指针前两位的数字不相等，说明该数字出现第三次了
    【1， 1， 2， 3， 3(i-2)，4， 3(i)， 3， 4(j)】// 用快指针覆盖。此时快指针迭代到终点，慢指针的索引的数值正好是数组的长度。
