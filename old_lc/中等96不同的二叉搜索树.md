# leetcode 96. 不同的二叉搜索树
`https://leetcode-cn.com/problems/unique-binary-search-trees/`
* 数学表达式，动态规划

# 二叉搜索树的特点
* 空树
* 左子树的值均小于根节点，右子树的值均大于根节点。且左右子树分别是一棵 BST。
* 高效率的排序和检索。

# 动态规划
* 定义两个函数`F(i, n), G(n)`，其中
    * `G(n)`：长度为 n 的序列能构建出的 BST 的个数。
    * `F(i, n)`：根节点为 i，长度为 n 的不同二叉树的个数。
    * 对于序列`[1,2,3,4,5,6,7]`，可以构建出 G(7) 个 BST
        * `G(7) = F(1, 7) + F(2, 7) + F(3, 7) + ... +F(7, 7)  = $$ \sum_{i=1}^{7} G(i, 7) $$`
        * `[1,2,3,4,5,6,7]`以 3 为根节点，左子树的序列为 `[1,2]`，右子树的序列为`[4,5,6,7]`，所以`F(3, 7) = G(2) * G(4)`。
        * `F(i, n) = G(i-1) * G(n-i)`。
        * `G(n) = \sum_{i=1}^{n} (F(i, n))= \sum_{i=1}^{n} (G(i-1) * G(n-i))`
    * `base case`: 对于`n=0, n=1`两种情况都有`G(0) = 1, G(1) = 1`。
    
    故代码如下
```
    class Solution {
public:
    int numTrees(int n) {
        vector<int> G(n+1, 0);
        G[0] = 1;
        G[1] = 1;
        for(int i=2; i <= n;i++) {
            for(int j = 1;j <= i;j++) {
                G[i] += G[j-1] * G[i - j];
            }
        }
        return G[n];
    }
};
```

# 复杂度分析
* 时间复杂度：O(n^2)
* 空间复杂度：O(n)

# 优化
上面推导出的 `G(n)` 推导式，在数学上被称为“卡特兰数”，有更便捷的计算公式，可以将时间复杂度降到 `O(n)`, 将空间复杂度降到 `O(1)`。